// -*- mode:c++ -*-

/*
 * Copyright (c) 2009-2012 Mark D. Hill and David A. Wood
 * Copyright (c) 2010-2012 Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer;
 * redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution;
 * neither the name of the copyright holders nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

machine(MachineType:L1Cache, "MSI cache")
    : Sequencer * sequencer;
      CacheMemory * cacheMemory;
      Cycles cache_response_latency := 12;
      Cycles issue_latency := 2;
      bool send_evictions;

      MessageBuffer * requestToDir, network="To", virtual_network="0", vnet_type="request";
      MessageBuffer * responseToDirOrSibling, network="To", virtual_network="2", vnet_type="response";

      MessageBuffer * forwardFromDir, network="From", virtual_network="1", vnet_type="forward";
      MessageBuffer * responseFromDirOrSibling, network="From", virtual_network="2", vnet_type="response";

      MessageBuffer * mandatoryQueue;
{
  // STATES
  state_declaration(State, desc="Cache states") {
    I, AccessPermission:Invalid, desc="Not Present/Invalid";
    IS_D, AccessPermission:Invalid, desc="Invalid moving to S, waiting for data";
    IM_AD, AccessPermission:Invalid, desc="Invalid moving to M, waiting for acks and data";
    IM_A, AccessPermission:Busy, desc="Invalid moving to M, waiting for acks";
    S, AccessPermission:Read_Only, desc="Shared. Read-only, other caches may have block";
    SM_AD, AccessPermission:Read_Only, desc="Shared moving to M, waiting for acks and data";
    SM_A, AccessPermission:Read_Only, desc="Shared moving to M, waiting for acks";
    M, AccessPermission:Read_Write, desc="Modified. Read & write permissions. Owner of block";
    MI_A, AccessPermission:Busy, desc="Modified moving to I, waiting for put ack";
    SI_A, AccessPermission:Busy, desc="Shared moving to I, waiting for put ack";
    II_A, AccessPermission:Invalid, desc="Received Invalidate or Fwd-Get while moving to I, waiting for put ack";
  }

  // EVENTS
  enumeration(Event, desc="Cache events") {
    // From processor
    Load, desc="Load request from processor";
    Store, desc="Store request from processor";

    // Internal event (triggered from processor requests)
    Replacement, desc="Replace a block";

    // Forwarded request from other cache via dir on the forward network
    FwdGetS, desc="Directory forwarded GetS. We must have block in M to respond.";
    FwdGetM, desc="Directory forwarded GetS. We must have block in M to respond.";
    Inv, desc="Invalidate request from dir";
    PutAck, desc="Response from directory after issuing a put.";

    // Responses from directory
    DataDirNoAcks, desc="Data from directory (acks = 0)";
    DataDirAcks, desc="Data from directory (acks > 0)";

    // Responses from other caches
    DataOwner, desc="Data from owner";
    InvAck, desc="Invalidation ack from other cache after Inv";

    // Special event to simplify implementation
    LastInvAck, desc="Triggered after last ack is received";
  }

  // STRUCTURE DEFINITIONS
  structure(Entry, desc="Cache entry", interface="AbstractCacheEntry") {
    State CacheState,        desc="cache state";
    DataBlock DataBlk,       desc="Data in the block";
  }

  // TBE fields
  structure(TBE, desc="Entry for transient requests") {
    State TBEState,          desc="Transient state";
    DataBlock DataBlk,       desc="Data for the block, required for concurrent writebacks";
    int AcksOutstanding, default=0, desc="Number of acks left to receive";
  }

  structure(TBETable, external="yes") {
    TBE lookup(Addr);
    void allocate(Addr);
    void deallocate(Addr);
    bool isPresent(Addr);
  }


  // STRUCTURES
  TBETable TBEs, template="<L1Cache_TBE>", constructor="m_number_of_TBEs";

  // PROTOTYPES
  Tick clockEdge();
  void set_cache_entry(AbstractCacheEntry a);
  void unset_cache_entry();
  void set_tbe(TBE b);
  void unset_tbe();
  MachineID mapAddressToMachine(Addr addr, MachineType mtype);

  Entry getCacheEntry(Addr address), return_by_pointer="yes" {
    return static_cast(Entry, "pointer", cacheMemory.lookup(address));
  }

  // FUNCTIONS
  State getState(TBE tbe, Entry cache_entry, Addr addr) {

    if (is_valid(tbe)) {
      return tbe.TBEState;
    }
    else if (is_valid(cache_entry)) {
      return cache_entry.CacheState;
    }
    else {
      return State:I;
    }
  }

  void setState(TBE tbe, Entry cache_entry, Addr addr, State state) {

    if (is_valid(tbe)) {
      tbe.TBEState := state;
    }

    if (is_valid(cache_entry)) {
      cache_entry.CacheState := state;
    }
  }

  AccessPermission getAccessPermission(Addr addr) {
    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      return L1Cache_State_to_permission(tbe.TBEState);
    }

    Entry cache_entry := getCacheEntry(addr);
    if(is_valid(cache_entry)) {
      return L1Cache_State_to_permission(cache_entry.CacheState);
    }

    return AccessPermission:NotPresent;
  }

  void setAccessPermission(Entry cache_entry, Addr addr, State state) {
    if (is_valid(cache_entry)) {
      cache_entry.changePermission(L1Cache_State_to_permission(state));
    }
  }

  void functionalRead(Addr addr, Packet *pkt) {
    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      testAndRead(addr, tbe.DataBlk, pkt);
    } else {
      testAndRead(addr, getCacheEntry(addr).DataBlk, pkt);
    }
  }

  int functionalWrite(Addr addr, Packet *pkt) {
    int num_functional_writes := 0;

    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      num_functional_writes := num_functional_writes +
        testAndWrite(addr, tbe.DataBlk, pkt);
      return num_functional_writes;
    }

    num_functional_writes := num_functional_writes +
        testAndWrite(addr, getCacheEntry(addr).DataBlk, pkt);
    return num_functional_writes;
  }

  // NETWORK PORTS

  out_port(request_out, RequestMsg, requestToDir);
  out_port(response_out, ResponseMsg, responseToDirOrSibling);

  in_port(response_in, ResponseMsg, responseFromDirOrSibling) {
    if (response_in.isReady(clockEdge())) {
      peek(response_in, ResponseMsg) {
        // in_msg is special variable that exists inside peek code block
        // grab cache and TBE entry
        Entry cache_entry := getCacheEntry(in_msg.addr);
        TBE tbe := TBEs[in_msg.addr];
        // TBE must be valid since this is a response message to a previous request
        assert(is_valid(tbe));

        if (machineIDToMachineType(in_msg.sender) == MachineType:Directory) {
          if (in_msg.Type != CoherenceResponseType:Data) {
            error("Directory should only reply with data");
          }
          assert(in_msg.Acks + tbe.AcksOutstanding >= 0);
          if (in_msg.Acks + tbe.AcksOutstanding == 0) {
            trigger(Event:DataDirNoAcks, in_msg.addr, cache_entry, tbe);
          } else {
            trigger(Event:DataDirAcks, in_msg.addr, cache_entry, tbe);
          }
        } else {
          if (in_msg.type == CoherenceResponseType:Data) {
            trigger(Event:DataOwner, in_msg.addr, cache_entry, tbe);
          } else if (in_msg.Type == CoherenceResponseType:InvAck) {
            DPRINTF(RubySlicc, "Got inv ack. %d left\n", tbe.AcksOutstanding);
            if (tbe.AcksOutstanding == 1) {
              trigger(Event:LastInvAck, in_msg.addr, cache_entry, tbe);
            } else {
              trigger(Event:InvAck, in_msg.addr, cache_entry, tbe);
            }
          } else {
            error("Unexpected response from other cache");
          }
        }
      }
    }
  }

  // define processing for messages forwarded from directory to cache
  in_port(forward_in, RequestMsg, forwardFromDir) {
    if (forward_in.isReady(clockEdge())) {
      peek(forward_in, RequestMsg) {
        // in_msg available
        Entry cache_entry := getCacheEntry(in_msg.addr);
        TBE tbe := TBEs[in_msg.addr];

        if (in_msg.Type == CoherenceRequestType:GetS) {
          trigger(Event:FwdGetS, in_msg.addr cache_entry, tbe);
        } else if (in_msg.Type == CoherenceRequestType:GetM) {
          trigger(Event:FwdGetM, in_msg.addr cache_entry, tbe);
        } else if (in_msg.Type == CoherenceRequestType:Inv) {
          trigger(Event:Inv, in_msg.addr cache_entry, tbe);
        } else if (in_msg.Type == CoherenceRequestType:PutAck) {
          trigger(Event:PutAck, in_msg.addr cache_entry, tbe);
        } else {
          error("Unexpected forward message!");
        }
      }
    }
  }

  // mandatory queue - must be last in code because lowest priority
  // processes requests coming from the processor to the cache controller
  in_port(mandatory_in, RubyRequest, mandatoryQueue) {
    if (mandatory_in.isReady(clockEdge())) {
      // block_on serializes requests to the same Line Address
      // TODO: for BP could we add way group and block on way group?
      peek(mandatory_in, RubyRequest, block_on="LineAddress") {
        Entry cache_entry := getCacheEntry(in_msg.LineAddress);
        TBE tbe := TBEs[in_msg.LineAddress];

        // if block is not in the cache and there is no available block, do a replacement
        if (is_invalid(cache_entry) && cacheMemory.cacheAvail(in_msg.LineAddress) == false) {
          Addr addr := cacheMemory.cacheProbe(in_msg.LineAddress);
          Entry victim_entry := getCacheEntry(addr);
          TBE victim_tbe := TBEs[addr];
          trigger(Event:Replacement, addr, victim_entry, victim_tbe);
        } else {
          if (in_msg.Type == RubyRequestType:LD || in_msg.Type == RubyRequestType:IFETCH) {
            trigger(Event:Load, in_msg.LineAddress, cache_entry, tbe);
          } else if (in_msg.Type == RubyRequestType:ST) {
            trigger(Event:Store, in_msg.LineAddress, cache_entry, tbe);
          } else {
            error("Unexpected type from processor!");
          }
        }
      }
    }
  }

  // ACTIONS
  action(sendGetS, "gS", desc="Send GetS to the directory") {
    // three variables in scope here automatically, from the call to trigger():
    // address, cache_entry, tbe
    enqueue(request_out, RequestMsg, issue_latency) {
      // out_msg is in scope automatically when sending to out port
      out_msg.addr := address;
      out_msg.Type := CoherenceRequestType:GetS;
      out_msg.Destination.add(mapAddressToMachine(address, MachineType:Directory));
      out_msg.MessageSize := MessageSizeType:Control;
      out_msg.Requestor := machineID;
    }
  }

  action(z_stall, "z", desc="stall") {
    // do nothing
  }

  // TRANSITIONS

  transition({IS, IM, MI, II, MII}, {Load, Ifetch, Store, Replacement}) {
    z_stall;
  }

  transition({IS, IM}, {Fwd_GETX, Inv}) {
    z_stall;
  }

  transition(MI, Inv) {
    o_popForwardedRequestQueue;
  }

  transition(M, Store) {
    s_store_hit;
    p_profileHit;
    m_popMandatoryQueue;
  }

  transition(M, {Load, Ifetch}) {
    r_load_hit;
    p_profileHit;
    m_popMandatoryQueue;
  }

  transition(I, Inv) {
    o_popForwardedRequestQueue;
  }

  transition(I, Store, IM) {
    v_allocateTBE;
    i_allocateL1CacheBlock;
    a_issueRequest;
    p_profileMiss;
    m_popMandatoryQueue;
  }

  transition(I, {Load, Ifetch}, IS) {
    v_allocateTBE;
    i_allocateL1CacheBlock;
    a_issueRequest;
    p_profileMiss;
    m_popMandatoryQueue;
  }

  transition(IS, Data, M) {
    u_writeDataToCache;
    rx_load_hit;
    w_deallocateTBE;
    n_popResponseQueue;
  }

  transition(IM, Data, M) {
    u_writeDataToCache;
    sx_store_hit;
    w_deallocateTBE;
    n_popResponseQueue;
  }

  transition(M, Fwd_GETX, I) {
    e_sendData;
    forward_eviction_to_cpu;
    o_popForwardedRequestQueue;
  }

  transition(I, Replacement) {
     h_deallocateL1CacheBlock;
  }

  transition(M, {Replacement,Inv},  MI) {
     v_allocateTBE;
     b_issuePUT;
     x_copyDataFromCacheToTBE;
     forward_eviction_to_cpu;
     h_deallocateL1CacheBlock;
  }

  transition(MI, Writeback_Ack, I) {
    w_deallocateTBE;
    o_popForwardedRequestQueue;
  }

  transition(MI, Fwd_GETX, II) {
    ee_sendDataFromTBE;
    o_popForwardedRequestQueue;
  }

  transition(MI, Writeback_Nack, MII) {
    o_popForwardedRequestQueue;
  }

  transition(MII, Fwd_GETX, I) {
    ee_sendDataFromTBE;
    w_deallocateTBE;
    o_popForwardedRequestQueue;
  }

  transition(II, Writeback_Nack, I) {
    w_deallocateTBE;
    o_popForwardedRequestQueue;
  }
}
